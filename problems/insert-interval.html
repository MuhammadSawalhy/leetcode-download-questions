<h2>Insert Interval</h2>

<h3>Statement</h3>

<p>
  You are given an array of non-overlapping intervals
  <code>intervals</code> where
  <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the
  start and the end of the <code>i<sup>th</sup></code> interval and
  <code>intervals</code> is sorted in ascending order by
  <code>start<sub>i</sub></code
  >. You are also given an interval <code>newInterval = [start, end]</code> that
  represents the start and end of another interval.
</p>

<p>
  Insert <code>newInterval</code> into <code>intervals</code> such that
  <code>intervals</code> is still sorted in ascending order by
  <code>start<sub>i</sub></code> and <code>intervals</code> still does not have
  any overlapping intervals (merge overlapping intervals if necessary).
</p>

<p>Return <code>intervals</code><em> after the insertion</em>.</p>

<p>
  <strong>Note</strong> that you don&#39;t need to modify
  <code>intervals</code> in-place. You can make a new array and return it.
</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]
<strong>Output:</strong> [[1,5],[6,9]]
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
<strong>Output:</strong> [[1,2],[3,10],[12,16]]
<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
  <li>
    <code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code>
  </li>
  <li><code>intervals[i].length == 2</code></li>
  <li>
    <code
      >0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup
        >5</sup
      ></code
    >
  </li>
  <li>
    <code>intervals</code> is sorted by <code>start<sub>i</sub></code> in
    <strong>ascending</strong> order.
  </li>
  <li><code>newInterval.length == 2</code></li>
  <li>
    <code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code>
  </li>
</ul>

<strong>Tags:</strong> Array

<h3>Hints</h3>

<ul>
  <li>
    Intervals Array is sorted. Can you use Binary Search to find the correct
    position to insert the new Interval.?
  </li>
  <li>
    Can you try merging the overlapping intervals while inserting the new
    interval?
  </li>
  <li>
    This can be done by comparing the end of the last interval with the start of
    the new interval and vice versa.
  </li>
</ul>

<h3>Solution Summary</h3>

Solution Overview We are given a sorted list of non-overlapping intervals and a
newInterval. The task is to insert the newInterval into the intervals while main
<h3>Solution</h3>

<p>[TOC]</p>
<h3>Solution</h3>
<hr />
<h4>Overview</h4>
<p>
  We are given a sorted list of non-overlapping <code>intervals</code> and a
  <code>newInterval</code>. The task is to insert the
  <code>newInterval</code> into the <code>intervals</code> while maintaining
  sorted order and ensuring no overlapping intervals. If there is any overlap,
  the overlapping intervals should be merged. In the end, return the intervals
  list with the addition of the new intervals.
</p>
<p>Two key observations are crucial for this problem:</p>
<ol>
  <li>
    The given intervals are already sorted in ascending order based on the start
    values.
  </li>
  <li>
    Initially, the intervals are non-overlapping, but inserting a new interval
    might lead to overlaps that need resolution by merging while maintaining
    sorted order.
  </li>
</ol>
<p>
  To solve this problem, we break it into three cases when comparing the current
  interval with the new interval: Case 1. The current interval ends before the
  new interval starts. Case 2. There is an overlap, and the intervals need
  merging. Case 3. The current interval starts after the new interval ends.
</p>
<p>A visual representation below illustrates all three scenarios:</p>
<p>
  <img
    alt="img"
    src="https://leetcode.com/problems/insert-interval/Figures/57_re/1.png"
  />
</p>
<p>
  Now let us consider the given problem description example with
  <code>intervals</code> and a <code>newInterval</code>:
</p>
<p><code>intervals = [[1, 3], [6, 9]] newInterval = [2, 5]</code></p>
<p>
  The first interval starts at 1 and ends at 3, while the second interval starts
  at 6 and ends at 9. The goal is to insert the <code>newInterval</code> into
  the existing list of <code>intervals</code>, maintaining sorted order.
</p>
<p>
  Upon analysis, we observe that the <code>newInterval</code> [2, 5] overlaps
  with the first interval [1, 3] because 2 is less than 3. Now, since we know
  the intervals need to be merged, we must ensure the merged interval covers the
  entire overlapping region.
</p>
<p>
  To achieve this, we take the maximum of the end of the first interval and the
  end of the new interval, as well as the minimum of the start of the first
  interval and the start of the new interval. Therefore, the merged interval
  becomes <code>[min(1, 2), max(3, 5)] = [1, 5]</code>.
</p>
<p>
  Moving on to the second interval [6, 9], its starting point (6) comes after
  the new interval's ending point (5). There is no overlap between them.
  Therefore, the second interval remains unchanged.
</p>
<p>
  | Original Intervals | New Interval | Action | Resulting Intervals |
  |-------------------- |--------------|----------------------------
  |----------------------| | [1,3] | [2,5] | New interval overlaps with the
  first interval [1,3]. Merge intervals by taking [min(1, 2), max(3, 5)] = [1,
  5]. | [1,5] | | [6,9] | | No overlap with the new interval [2,5]. Interval
  remains unchanged. | [6,9] |
</p>
<p>
  In conclusion, the final result is [[1, 5], [6, 9]], representing the
  intervals after inserting and merging the new interval [2, 5].
</p>
<p>
  In a concrete business context, this problem may be presented as follows:
  Suppose we have an array representing video watch times, where each segment
  consists of the start and stop times of a user watching a video. The task is
  to calculate the total number of unique minutes watched across all the video
  segments. This is fundamentally the same question.
</p>
<blockquote>
  <p>
    We recommend solving
    <a href="https://leetcode.com/problems/merge-intervals/">Merge Intervals</a>
    problem before attempting this question, as it provides valuable insights
    into pattern recognition. This question is an extension of the Merge
    Intervals concept, building upon the same principles.
  </p>
</blockquote>
<hr />
<h4>Approach 1: Linear Search</h4>
<h5>Intuition</h5>
<p>
  We can do a linear search by iterating through all the intervals and checking
  which one of the three conditions the intervals fall under:
</p>
<ol>
  <li>
    <p><strong>No Overlaps before Merging:</strong></p>
  </li>
  <li>
    <p>
      This occurs when the current interval ends before the new interval starts.
    </p>
  </li>
  <li>
    <p><strong>Overlapping and Merging:</strong></p>
  </li>
  <li>
    <p>
      This occurs when the starting point of the current interval is less than
      or equal to the ending point of the new interval
      (<code>newInterval[1]</code>), indicating an overlap. We can merge the
      current interval with the new interval by updating the start and end
      values of the new interval.
    </p>
  </li>
  <li>
    <p><strong>No Overlapping after Merging:</strong></p>
  </li>
  <li>
    <p>
      This occurs when the current interval starts after the new interval ends.
    </p>
  </li>
</ol>
<h6>1. Identifying Non-Overlapping Intervals Before Merging:</h6>
<p>
  We iterate through all intervals, checking whether the endpoint of the current
  interval (<code>intervals[i][1]</code>) is less than the starting point of the
  new interval (<code>newInterval[0]</code>). If this condition holds true, it
  indicates there is no overlap before merging, and we add the current interval
  to the result.
</p>
<h6>2. Identifying and Merging Overlapping Intervals:</h6>
<p>
  During the iteration, we identify overlap by comparing the endpoint of the new
  interval (<code>newInterval[1]</code>) with the starting point of the current
  interval (<code>intervals[i][0]</code>). When an overlap is detected, we merge
  the intervals by updating the start and end values of the new interval. The
  index (<code>i</code>) is then incremented to move to the next interval. After
  merging, the new interval is added to the result.
</p>
<h6>3. Identifying Non-Overlapping Intervals After Merging:</h6>
<p>
  As we have already added the non-overlapping intervals before
  <code>newInterval</code> and merged overlapping ones, the remaining intervals
  after are guaranteed not to overlap with the newly merged interval. We simply
  add these remaining intervals to the result.
</p>
<p>
  The following slideshow illustrates how the linear search algorithm is
  employed:
</p>
<p>!?!../Documents/57/57_LS.json:945,480!?!</p>
<h5>Algorithm</h5>
<ul>
  <li>
    Initialize variables <code>n</code> and <code>i</code> to store the size of
    intervals and the current index, respectively, and an empty array
    <code>res</code> to store the result.
  </li>
  <li>Case 1: No Overlap Before Insertion:</li>
  <li>
    Loop through intervals while <code>i</code> is less than <code>n</code> and
    the current interval's endpoint (<code>intervals[i][1]</code>) is less than
    the new interval's start point (<code>newInterval[0]</code>).
  </li>
  <li>
    Add the current interval from intervals to the <code>res</code> array.
  </li>
  <li>Increment <code>i</code> to move to the next interval.</li>
  <li>Case 2: Overlap and Merge:</li>
  <li>
    Loop through intervals while <code>i</code> is less than <code>n</code> and
    the new interval's endpoint (<code>newInterval[1]</code>) is greater than or
    equal to the current interval's start point (<code>intervals[i][0]</code>).
  </li>
  <li>
    Update the newInterval's start point to the minimum of its current start and
    the current interval's start.
  </li>
  <li>
    Update the newInterval's endpoint to the maximum of its current end and the
    current interval's end.
  </li>
  <li>
    This essentially merges overlapping intervals into a single larger interval.
  </li>
  <li>Increment <code>i</code> to move to the next interval.</li>
  <li>
    Add the updated <code>newInterval</code> to the <code>res</code> array,
    representing the merged interval.
  </li>
  <li>Case 3: No overlap after insertion:</li>
  <li>
    Loop through the remaining intervals (from index <code>i</code>) and add
    them to the <code>res</code> array.
    <ul>
      <li>
        This includes intervals that occur after the new interval and those that
        don't overlap, as they have already been correctly inserted in the
        previous iterations (previous two cases).
      </li>
    </ul>
  </li>
  <li>
    Return the <code>res</code> array containing all intervals with the new
    interval inserted correctly.
  </li>
</ul>
<h5>Implementation</h5>
<pre>
class Solution {
public:
    vector&lt;vector&lt;int>> insert(vector&lt;vector&lt;int>>&amp; intervals,
                               vector&lt;int>&amp; newInterval) {
        int n = intervals.size(), i = 0;
        vector&lt;vector&lt;int>> res;

        // Case 1: no overlapping case before the merge intervals
        // Compare ending point of intervals to starting point of newInterval
        while (i &lt; n &amp;&amp; intervals[i][1] &lt; newInterval[0]) {
            res.push_back(intervals[i]);
            i++;
        }

        // Case 2: overlapping case and merging of intervals
        while (i &lt; n &amp;&amp; newInterval[1] >= intervals[i][0]) {
            newInterval[0] = min(newInterval[0], intervals[i][0]);
            newInterval[1] = max(newInterval[1], intervals[i][1]);
            i++;
        }
        res.push_back(newInterval);

        // Case 3: no overlapping of intervals after newinterval being merged
        while (i &lt; n) {
            res.push_back(intervals[i]);
            i++;
        }
        return res;
    }
};</pre
>

<h5>Complexity Analysis</h5>
<p>Let $N$ be the number of intervals.</p>
<ul>
  <li>Time complexity: $O(N)$</li>
</ul>
<p>
  We iterate through the intervals once, and each interval is considered and
  processed only once.
</p>
<ul>
  <li>Space complexity: $O(1)$</li>
</ul>
<p>
  We only use the result (<code>res</code>) array to store output, so this could
  be considered $O(1)$.
</p>
<hr />
<h4>Approach 2: Binary Search</h4>
<h5>Intuition</h5>
<p>
  To apply binary search to a problem, a crucial requirement is that the input
  should have a monotonically increasing or decreasing nature. In our given
  scenario, it is explicitly stated that the input is already sorted with
  respect to the start value, indicating a monotonically increasing order.
  Therefore, we can confidently consider applying binary search.
</p>
<h6>1. Finding the Insertion Position</h6>
<p>
  As the intervals are sorted by start value, we perform a binary search
  comparing the starting point of the current interval
  (<code>intervals[mid][0]</code>) with the starting point of the new interval
  (<code>target</code>). If <code>intervals[mid][0]</code> is less than the
  target, it indicates that the insertion point should be to the right of the
  current position. Consequently, we update <code>left</code> to
  <code>mid + 1</code>. If it's greater, the insertion point should be to the
  left, so we update <code>right</code> to <code>mid - 1</code>. This process
  continues until <code>left</code> becomes greater than <code>right</code>,
  revealing the correct insertion position.
</p>
<h6>2. Handling Merging</h6>
<ol>
  <li>
    If <code>res</code> is empty or the end of the last interval in
    <code>res</code> is less than the starting point of the current interval, it
    indicates there is no overlap before merging. The current interval is
    directly added to <code>res</code> in such cases.
  </li>
  <li>
    If an overlap is detected, signifying the need for merging, the current
    interval is merged with the last interval in <code>res</code>. The end of
    the last interval in <code>res</code> is updated to the maximum of its
    current end and the end of the current interval.
  </li>
</ol>
<p>
  The following slideshow illustrates how the binary search algorithm is
  employed:
</p>
<p>!?!../Documents/57/57_BS.json:930,315!?!</p>
<h5>Algorithm</h5>
<ul>
  <li>
    If <code>intervals</code> is empty, it means there are no existing
    intervals, so we can simply return a array containing the
    <code>newInterval</code>.
  </li>
  <li>
    Perform a binary search to find the correct position to insert the new
    interval in the <code>intervals</code> array. It updates the values of
    <code>left</code> and <code>right</code> based on the comparison of the
    target value with the first element of the interval at the middle index.
  </li>
  <li>
    Initialize the variables <code>target</code> with the starting point of
    <code>newInterval</code> (i.e., <code>newInterval[0]</code>),
    <code>left</code> with 0, and <code>right</code> with <code>n - 1</code> to
    define the search space in the <code>intervals</code> array.
  </li>
  <li>
    Perform a binary search by repeatedly dividing the search space in half
    until <code>left</code> is greater than <code>right</code>.
  </li>
  <li>
    Calculate the middle index <code>mid</code> as the average of
    <code>left</code> and <code>right</code>.
  </li>
  <li>
    If the start of the interval at index <code>mid</code> is less than the
    target value, update <code>left</code> to <code>mid + 1</code> to search the
    right half of the search space. Otherwise, update <code>right</code> to
    <code>mid - 1</code> to search the left half of the search space.
  </li>
  <li>
    The search updates <code>left</code> and <code>right</code> until they
    converge to the correct position. Repeat until <code>left</code> is greater
    than <code>right</code>.
  </li>
  <li>
    Use <code>intervals.insert(intervals.begin() + left, newInterval)</code> to
    insert the <code>newInterval</code> at the correct position.
  </li>
  <li>Initialize an empty array <code>res</code> to store the result.</li>
  <li>Iterate through the sorted intervals.</li>
  <li>
    Check if <code>res</code> is empty or if the end of the last interval in
    <code>res</code> is less than the start of the current interval. If either
    condition is true, add the current interval to <code>res</code>.
  </li>
  <li>
    If there is an overlap, update the endpoint of the last interval in
    <code>res</code> to cover the current interval. This step ensures that
    non-overlapping intervals are added directly, and overlapping intervals are
    merged.
  </li>
  <li>
    The final merged and inserted intervals are stored in the
    <code>res</code> array, which is then returned.
  </li>
</ul>
<h5>Implementation</h5>
<pre>
class Solution {
public:
    vector&lt;vector&lt;int>> insert(vector&lt;vector&lt;int>>&amp; intervals,
                               vector&lt;int>&amp; newInterval) {
        // If the intervals vector is empty, return a vector containing the
        // newInterval
        if (intervals.empty()) {
            return {newInterval};
        }

        int n = intervals.size();
        int target = newInterval[0];
        int left = 0, right = n - 1;

        // Binary search to find the position to insert newInterval
        while (left &lt;= right) {
            int mid = (left + right) / 2;
            if (intervals[mid][0] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        // Insert newInterval at the found position
        intervals.insert(intervals.begin() + left, newInterval);

        // Merge overlapping intervals
        vector&lt;vector&lt;int>> res;
        for (const auto&amp; interval : intervals) {
            // If res is empty or there is no overlap, add the interval to the
            // result
            if (res.empty() || res.back()[1] &lt; interval[0]) {
                res.push_back(interval);
                // If there is an overlap, merge the intervals by updating the
                // end of the last interval in res
            } else {
                res.back()[1] = max(res.back()[1], interval[1]);
            }
        }

        return res;
    }
};</pre
>

<h5>Complexity Analysis</h5>
<p>Let $N$ be the number of intervals.</p>
<ul>
  <li>Time complexity: $O(N)$</li>
</ul>
<p>
  The binary search for finding the position to insert the
  <code>newInterval</code> has a time complexity of $O(\log N)$. However, the
  insertion of the <code>newInterval</code> into the list may take $O(N)$ time
  in the worst case, as it could involve shifting elements within the list.
  Consequently, the overall time complexity is $O(N + \log N)$, which simplifies
  to $O(N)$.
</p>
<ul>
  <li>Space complexity: $O(N)$</li>
</ul>
<p>
  We use the additional space to store the result (<code>res</code>) and perform
  calculations using <code>res,</code> so it does count towards the space
  complexity. In the worst case, the size of <code>res</code> will be
  proportional to the number of intervals in the input list.
</p>
