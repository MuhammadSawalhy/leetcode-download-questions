<h2>Valid Palindrome</h2>

<h3>Statement</h3>

<p>
  A phrase is a <strong>palindrome</strong> if, after converting all uppercase
  letters into lowercase letters and removing all non-alphanumeric characters,
  it reads the same forward and backward. Alphanumeric characters include
  letters and numbers.
</p>

<p>
  Given a string <code>s</code>, return <code>true</code
  ><em> if it is a <strong>palindrome</strong>, or </em><code>false</code
  ><em> otherwise</em>.
</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;A man, a plan, a canal: Panama&quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> &quot;amanaplanacanalpanama&quot; is a palindrome.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;race a car&quot;
<strong>Output:</strong> false
<strong>Explanation:</strong> &quot;raceacar&quot; is not a palindrome.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot; &quot;
<strong>Output:</strong> true
<strong>Explanation:</strong> s is an empty string &quot;&quot; after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
  <li>
    <code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code>
  </li>
  <li><code>s</code> consists only of printable ASCII characters.</li>
</ul>

<strong>Tags:</strong> Two Pointers, String

<h3>Solution</h3>

<p>
  The problem asks us to determine if a given string is a palindrome after
  preprocessing. Preprocessing involves converting all uppercase letters to
  lowercase and removing all non-alphanumeric characters. After preprocessing,
  we need to check if the string reads the same forward and backward.
</p>

<p>
  A straightforward approach is to use two pointers, one starting from the
  beginning of the string and the other from the end. We move the pointers
  towards each other, comparing the characters at each pointer. If the
  characters are different, the string is not a palindrome. If the pointers
  meet, the string is a palindrome.
</p>

<pre>
<code>
class Solution {
    public boolean isPalindrome(String s) {
        s = s.toLowerCase();
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                sb.append(c);
            }
        }
        String filteredString = sb.toString();
        int left = 0;
        int right = filteredString.length() - 1;

        while (left < right) {
            if (filteredString.charAt(left) != filteredString.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
</code>
</pre>
