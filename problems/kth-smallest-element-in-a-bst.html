<h2>Kth Smallest Element in a BST</h2>

<h3>Statement</h3>

<p>
  Given the <code>root</code> of a binary search tree, and an integer
  <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code>
  <em
    >smallest value (<strong>1-indexed</strong>) of all the values of the nodes
    in the tree</em
  >.
</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<img
  alt=""
  src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg"
  style="width: 212px; height: 301px"
/>
<pre>
 <strong>Input:</strong> root = [3,1,4,null,2], k = 1
 <strong>Output:</strong> 1
 </pre
>

<p><strong class="example">Example 2:</strong></p>
<img
  alt=""
  src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg"
  style="width: 382px; height: 302px"
/>
<pre>
 <strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3
 <strong>Output:</strong> 3
 </pre
>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
  <li>The number of nodes in the tree is <code>n</code>.</li>
  <li>
    <code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code>
  </li>
  <li>
    <code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code>
  </li>
</ul>

<p>&nbsp;</p>
<p>
  <strong>Follow up:</strong> If the BST is modified often (i.e., we can do
  insert and delete operations) and you need to find the kth smallest
  frequently, how would you optimize?
</p>

<strong>Tags:</strong> Tree, Depth-First Search, Binary Search Tree, Binary Tree

<h3>Hints</h3>

<ul>
  <li>Try to utilize the property of a BST.</li>
  <li>Try in-order traversal. (Credits to @chan13)</li>
  <li>What if you could modify the BST node's structure?</li>
  <li>The optimal runtime complexity is O(height of BST).</li>
</ul>

<h3>Solution</h3>

<p>
  The most intuitive approach is to perform an in-order traversal of the BST.
  Since in-order traversal visits nodes in ascending order for a BST, the k-th
  node visited during the traversal will be the k-th smallest element.
</p>

<pre>
 # Definition for a binary tree node.
 # class TreeNode:
 #     def __init__(self, val=0, left=None, right=None):
 #         self.val = val
 #         self.left = left
 #         self.right = right
 class Solution:
  def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
  def inorder(node):
  if not node:
  return []
  return inorder(node.left) + [node.val] + inorder(node.right)

  sorted_list = inorder(root)
  return sorted_list[k-1]
 </pre
>
