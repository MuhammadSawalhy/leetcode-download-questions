<h2>Word Break</h2>

<h3>Statement</h3>

<p>
  Given a string <code>s</code> and a dictionary of strings
  <code>wordDict</code>, return <code>true</code> if <code>s</code> can be
  segmented into a space-separated sequence of one or more dictionary words.
</p>

<p>
  <strong>Note</strong> that the same word in the dictionary may be reused
  multiple times in the segmentation.
</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]
<strong>Output:</strong> true
<strong>Explanation:</strong> Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.
Note that you are allowed to reuse a dictionary word.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]
<strong>Output:</strong> false
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
  <li><code>1 &lt;= s.length &lt;= 300</code></li>
  <li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
  <li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
  <li>
    <code>s</code> and <code>wordDict[i]</code> consist of only lowercase
    English letters.
  </li>
  <li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>
</ul>

<strong>Tags:</strong> Array, Hash Table, String, Dynamic Programming, Trie,
Memoization

<h3>Solution Summary</h3>

Video Solution Â  Solution Article Approach 1: Breadth-First Search Intuition
Let's imagine the indices of s as a graph. Each index can be thought of as a
node,
<h3>Solution</h3>

<hr />
<h4>Approach 1: Breadth-First Search</h4>
<p><strong>Intuition</strong></p>
<p>
  Let's imagine the indices of <code>s</code> as a graph. Each index can be
  thought of as a node, which represents building <code>s</code> up to the
  index.
</p>
<p>
  Adding a word to an existing string is like an edge between nodes. For a node
  <code>start</code>, we can move to node <code>end</code> if the substring of
  <code>s</code> between <code>start, end</code> exists in
  <code>wordDict</code>.
</p>
<p>
  For example, let's say we have <code>s = "leetcode"</code> and
  <code>wordDict = ["leet", "code"]</code>. We are currently at node
  <code>4</code>, which implies that we have built <code>"leet"</code> (the
  first 4 characters of <code>s</code>). We can move to node <code>8</code>,
  because the substring of <code>s</code> with indices <code>[4, 8)</code> is
  <code>"code"</code>, which is in <code>wordDict</code>.
</p>
<p>
  We start at node <code>0</code>, which represents the empty string. We want to
  reach node <code>s.length</code>, which implies that we have built the entire
  string. We can run a BFS to accomplish this traversal. If you're not familiar
  with BFS, check out the relevant
  <a
    href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/"
    >Explore Card</a
  >.
</p>
<p>
  At each node <code>start</code>, we iterate over all the nodes
  <code>end</code> that come after <code>start</code>. For each
  <code>end</code>, we check if the substring between <code>start, end</code> is
  in <code>wordDict</code>. If it is, we can add <code>end</code> to the queue.
</p>
<p>
  We will first convert <code>wordDict</code> into a set so that we can perform
  the checks in constant time. We will also use a data structure
  <code>seen</code> to prevent us from visiting a node more than once.
</p>
<p><strong>Algorithm</strong></p>
<ol>
  <li>Convert <code>wordDict</code> into a set <code>words</code>.</li>
  <li>
    Initialize a <code>queue</code> with <code>0</code> and a set
    <code>seen</code>.
  </li>
  <li>While the <code>queue</code> is not empty:</li>
  <li>Remove the first element, <code>start</code>.</li>
  <li>If <code>start == s.length</code>, return <code>true</code>.</li>
  <li>
    Iterate <code>end</code> from <code>start + 1</code> up to and including
    <code>s.length</code>. For each <code>end</code>, if <code>end</code> has
    not been visited yet,
    <ul>
      <li>
        Check the substring starting at <code>start</code> and ending before
        <code>end</code>. If it is in <code>words</code>, add
        <code>end</code> to the queue and mark it in <code>seen</code>.
      </li>
    </ul>
  </li>
  <li>
    Return <code>false</code> if the BFS finishes without reaching the final
    node.
  </li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
class Solution {
public:
    bool wordBreak(string s, vector&lt;string>&amp; wordDict) {
        unordered_set&lt;string> words(wordDict.begin(), wordDict.end());
        queue&lt;int> queue;
        vector&lt;bool> seen(s.length(), false);
        queue.push(0);

        while (!queue.empty()) {
            int start = queue.front();
            queue.pop();

            if (start == s.length()) {
                return true;
            }

            for (int end = start + 1; end &lt;= s.length(); end++) {
                if (seen[end]) {
                    continue;
                }

                if (words.find(s.substr(start, end - start)) != words.end()) {
                    queue.push(end);
                    seen[end] = true;
                }
            }
        }

        return false;
    }
};</pre
>

<p><strong>Complexity Analysis</strong></p>
<p>
  Given $n$ as the length of <code>s</code>, $m$ as the length of
  <code>wordDict</code>, and $k$ as the average length of the words in
  <code>wordDict</code>,
</p>
<ul>
  <li>Time complexity: $O(n^3 + m \cdot k)$</li>
</ul>
<p>
  There are $O(n)$ nodes. Because of <code>seen</code>, we never visit a node
  more than once. At each node, we iterate over the nodes in front of the
  current node, of which there are $O(n)$. For each node <code>end</code>, we
  create a substring, which also costs $O(n)$.
</p>
<p>
  Therefore, handling a node costs $O(n^2)$, so the BFS could cost up to
  $O(n^3)$. Finally, we also spent $O(m \cdot k)$ to create the set
  <code>words</code>.
</p>
<ul>
  <li>Space complexity: $O(n + m \cdot k)$</li>
</ul>
<p>
  We use $O(n)$ space for <code>queue</code> and <code>seen</code>. We use $O(m
  \cdot k)$ space for the set <code>words</code>.
</p>
<p><br /></p>
<hr />
<h4>Approach 2: Top-Down Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<blockquote>
  <p>
    If you're not familiar with dynamic programming, we recommend checking out
    the
    <a href="https://leetcode.com/explore/featured/card/dynamic-programming/"
      >Dynamic Programming explore card</a
    >. This problem is on the difficult side, so we will assume that readers are
    already familiar with the principles of DP.
  </p>
</blockquote>
<p>
  Let's have a function <code>dp</code> that returns a boolean indicating if it
  is possible to build <code>s</code> up to and including the index
  <code>i</code>.
</p>
<p>
  For example, given <code>s = "leetcode"</code> and
  <code>wordDict = ["leet", "code"]</code>, <code>dp(3)</code> would return
  <code>true</code>. <code>s</code> up to index <code>3</code> is
  <code>"leet"</code>, and we can build <code>"leet"</code> using the words in
  <code>wordDict</code>. The answer to the problem would be
  <code>dp(s.length - 1)</code>, which represents if we can build
  <code>s</code>.
</p>
<p>
  The base case of this function is when <code>i &lt; 0</code>. This would
  represent an empty string, and we can always build an empty string by doing
  nothing. Therefore, <code>dp(i) = true</code> for <code>i &lt; 0</code>.
</p>
<p>
  Given an index <code>i</code>, we need a recurrence relation to determine if
  <code>dp(i)</code> is <code>true</code> or <code>false</code>. For
  <code>dp(i)</code> to be <code>true</code>, there are two requirements:
</p>
<ol>
  <li>
    First, there needs to be a <code>word</code> from <code>wordDict</code> that
    <strong>ends</strong> at index <code>i</code>. Given a <code>word</code>,
    the substring of <code>s</code> from indices
    <code>i - word.length + 1</code> up to and including <code>i</code> should
    match <code>word</code>. We can check every <code>word</code> for this.
  </li>
  <li>
    If we manage to find a <code>word</code> that <strong>ends</strong> at index
    <code>i</code>, we would need to add it on top of another string (since we
    are building <code>s</code> by joining words together one by one). We need
    to make sure that the string we are adding onto is also buildable. If we
    find a <code>word</code> that passes the first check, it means
    <code>word</code> would start at index <code>i - word.length + 1</code>. The
    index before that is <code>i - word.length</code>. To check if the string
    ending at that index is buildable, we can refer to
    <code>dp(i - word.length)</code>.
  </li>
</ol>
<p>This gives us our recurrence relation:</p>
<p>
  $\large{\text{dp(i)} = \text{any}(\text{s}[\text{i - word.length + 1, i}] ==
  \text{word &amp;&amp; dp(i - \text{word.length})})}$
</p>
<p>
  That is, there exists any <code>word</code> that satisfies both of the listed
  conditions.
</p>
<p>
  We can implement a recursive function <code>dp(i)</code> that implements the
  base cases and recurrence. We need to use memoization to avoid repeated
  computation.
</p>
<p>!?!../Documents/139.json:960,540!?!</p>
<p><strong>Algorithm</strong></p>
<ol>
  <li>
    Declare a data structure <code>memo</code> that stores the values of
    <code>dp</code> for each index.
  </li>
  <li>Create a function <code>dp(i)</code>:</li>
  <li>If <code>i &lt; 0</code>, return <code>true</code>.</li>
  <li>
    If we already calculated <code>i</code>, return the value stored in
    <code>memo</code>.
  </li>
  <li>
    Iterate over <code>wordDict</code>. For each <code>word</code>:
    <ul>
      <li>
        Check the substring of <code>s</code> ending at <code>i</code> with the
        same length as <code>word</code>. If the substring matches, and
        <code>dp(i - word.length)</code> is <code>true</code>, return
        <code>true</code>.
      </li>
    </ul>
  </li>
  <li>
    If no <code>word</code> satisfying the criteria was found, return
    <code>false</code>.
  </li>
  <li>Return <code>dp(s.length - 1)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
  <p>
    In Python, the
    <a
      href="https://docs.python.org/3/library/functools.html"
      target="_blank"
      rel="noopener noreferrer"
      >functools</a
    >
    module provides super handy tools that automatically memoize a function for
    us. We're going to use the <code>@cache</code> decorator in the Python
    implementation.
  </p>
  <p>
    In Java and C++, we will use an array <code>memo</code> to save values.
    <code>memo[i] = -1</code> if we haven't calculated yet,
    <code>memo[i] = 0</code> if <code>dp(i) = false</code>, and
    <code>memo[i] = 1</code> if <code>dp(i) = true</code>.
  </p>
</blockquote>
<pre>
class Solution {
public:
    vector&lt;int> memo;
    vector&lt;string> wordDict;
    string s;

    bool wordBreak(string s, vector&lt;string>&amp; wordDict) {
        memo = vector(s.length(), -1);
        this->wordDict = wordDict;
        this->s = s;
        return dp(s.length() - 1);
    }

    bool dp(int i) {
        if (i &lt; 0) return true;

        if (memo[i] != -1) {
            return memo[i] == 1;
        }

        for (string word : wordDict) {
            int currSize = word.length();
            // Handle out of bounds case
            if (i - currSize + 1 &lt; 0) {
                continue;
            }

            if (s.substr(i - currSize + 1, currSize) == word &amp;&amp;
                dp(i - currSize)) {
                memo[i] = 1;
                return true;
            }
        }

        memo[i] = 0;
        return false;
    }
};</pre
>

<p><strong>Complexity Analysis</strong></p>
<p>
  Given $n$ as the length of <code>s</code>, $m$ as the length of
  <code>wordDict</code>, and $k$ as the average length of the words in
  <code>wordDict</code>,
</p>
<ul>
  <li>Time complexity: $O(n \cdot m \cdot k)$</li>
</ul>
<p>
  There are $n$ states of <code>dp(i)</code>. Because of memoization, we only
  calculate each state once. To calculate a state, we iterate over $m$ words,
  and for each word perform some substring operations which costs $O(k)$.
  Therefore, calculating a state costs $O(m \cdot k)$, and we need to calculate
  $O(n)$ states.
</p>
<ul>
  <li>Space complexity: $O(n)$</li>
</ul>
<p>
  The data structure we use for memoization and the recursion call stack can use
  up to $O(n)$ space.
</p>
<p><br /></p>
<hr />
<h4>Approach 3: Bottom-Up Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<p>
  The same algorithm can be implemented iteratively. Instead of using a function
  <code>dp(i)</code>, we will use an array <code>dp</code> where
  <code>dp[i]</code> represents the same thing that <code>dp(i)</code> did. We
  can use the same recurrence relation:
</p>
<p>
  $\large{\text{dp[i]} = \text{any}(\text{s}[\text{i - word.length + 1, i}] ==
  \text{word &amp;&amp; dp[i - \text{word.length}]})}$
</p>
<p>
  In top-down, we started at the top (<code>s.length - 1</code>) and work our
  way down to the base cases. In bottom-up, we start at the bottom
  <code>(i = 0)</code> and work our way up to the top.
</p>
<p>
  Before we check <code>dp[i - word.length]</code>, we should check if
  <code>i == word.length - 1</code>. This would mean that the current
  <code>word</code> we are placing to end at index <code>i</code> is the first
  word. <code>i - word.length</code> would be negative, so we need to separately
  check this case.
</p>
<p><strong>Algorithm</strong></p>
<ol>
  <li>
    Initialize an array <code>dp</code> with the same length as
    <code>s</code> and all values initially set to <code>false</code>.
  </li>
  <li>
    Iterate <code>i</code> over the indices of <code>s</code>. At each
    <code>i</code>:
  </li>
  <li>
    Iterate over each <code>word</code> in <code>wordDict</code>:
    <ul>
      <li>
        Check if <code>i == word.length - 1</code> or
        <code>dp[i - word.length] = true</code>.
      </li>
      <li>
        If so, and the substring of <code>s</code> ending at <code>i</code> with
        the same length as <code>word</code> matches, set
        <code>dp[i] = true</code> and <code>break</code>.
      </li>
    </ul>
  </li>
  <li>Return <code>dp[s.length - 1]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
class Solution {
public:
    bool wordBreak(string s, vector&lt;string>&amp; wordDict) {
        vector&lt;bool> dp(s.length());
        for (int i = 0; i &lt; s.length(); i++) {
            for (string word : wordDict) {
                // Handle out of bounds case
                if (i &lt; word.length() - 1) {
                    continue;
                }

                if (i == word.length() - 1 || dp[i - word.length()]) {
                    if (s.substr(i - word.length() + 1, word.length()) ==
                        word) {
                        dp[i] = true;
                        break;
                    }
                }
            }
        }

        return dp[s.length() - 1];
    }
};</pre
>

<p><strong>Complexity Analysis</strong></p>
<p>
  Given $n$ as the length of <code>s</code>, $m$ as the length of
  <code>wordDict</code>, and $k$ as the average length of the words in
  <code>wordDict</code>,
</p>
<ul>
  <li>Time complexity: $O(n \cdot m \cdot k)$</li>
</ul>
<p>
  The logic behind the time complexity is identical to the previous approach. It
  costs us $O(m \cdot k)$ to calculate each state, and we calculate $O(n)$
  states in total.
</p>
<ul>
  <li>Space complexity: $O(n)$</li>
</ul>
<p>We use an array <code>dp</code> of length $n$.</p>
<p><br /></p>
<hr />
<h4>Approach 4: Trie Optimization</h4>
<p><strong>Intuition</strong></p>
<p>
  In the previous approach, we iterated over each state <code>i</code> and then
  calculated <code>dp[i]</code>. To calculate a given <code>dp[i]</code>, we did
  the following:
</p>
<ul>
  <li>Iterate over every <code>word</code> in <code>wordDict</code></li>
  <li>Check if each <code>word</code> ended at the current index</li>
</ul>
<p>
  This cost us $O(m \cdot k)$. In the problem constraints, we can see that the
  maximum value of $m \cdot k$ is <code>20,000</code>, so this is expensive. We
  can optimize the time it takes to calculate a given <code>dp[i]</code> by
  using a trie.
</p>
<p>
  A trie is a data structure that can be used to efficiently search for strings.
  If you are not familiar with tries, we highly recommend you read the official
  solution to
  <a href="https://leetcode.com/problems/implement-trie-prefix-tree/solution"
    >this problem</a
  >
  before proceeding with this approach.
</p>
<p>
  To summarize, a trie is a tree where each node is labeled. Here, we label each
  node with a character. The path from the root to any node represents the
  string that is built by the nodes on the path. The root represents the empty
  string.
</p>
<p>
  <img
    src="https://leetcode.com/problems/word-break/Figures/139/4.png"
    width="960"
  />
  <br />
</p>
<p>
  We can start by building a trie from the words in <code>wordDict</code>. Each
  trie node will have an additional attribute <code>isWord</code> which
  indicates if the current node represents a word from <code>wordDict</code>.
  Then, we will calculate the same <code>dp</code> array as in the previous
  approach. We will calculate each state as follows:
</p>
<ul>
  <li>
    First, check if <code>i == 0</code> (placing first word) or
    <code>dp[i - 1]</code> (we could build the string up to this point). If
    neither are true, move on to the next state <code>i + 1</code>.
  </li>
  <li>
    Otherwise, we see if <code>dp[i]</code> can be <code>true</code>. Initialize
    a node <code>curr</code> at the <code>root</code> of the trie.
  </li>
  <li>
    Start iterating with a variable <code>j</code> from index <code>i</code>.
    For each character <code>s[j]</code>, check if we can traverse the trie.
  </li>
  <li>
    If we can't traverse the trie, it means no words exist starting at index
    <code>i</code> and ending at index <code>j</code> or beyond. We can break
    from the loop and move on to the next state <code>i + 1</code>.
  </li>
  <li>
    If we can traverse the trie, we move to the child node. We check the child's
    <code>isWord</code> attribute. If it is <code>true</code>, it means there is
    a word in <code>wordDict</code> starting at index <code>i</code> and ending
    at index <code>j</code>. We set <code>dp[j] = true</code>.
  </li>
  <li>
    We continue traversing the trie until we reach a dead end or
    <code>j</code> reaches the end of the string.
  </li>
</ul>
<p>
  This allows us to handle each state in $O(n)$ instead of $O(m \cdot k)$, which
  is a big improvement since $n \leq 300$.
</p>
<p><strong>Algorithm</strong></p>
<ol>
  <li>
    Build a trie from <code>wordDict</code>. Each node should also have an
    <code>isWord</code> attribute. Store the root of the trie in
    <code>root</code>.
  </li>
  <li>
    Initialize an array <code>dp</code> with the same length as
    <code>s</code> and all values initially set to <code>false</code>.
  </li>
  <li>
    Iterate <code>i</code> over the indices of <code>s</code>. At each
    <code>i</code>:
  </li>
  <li>
    Check if <code>i == 0</code> or <code>dp[i - 1] = true</code>. If not,
    continue to the next <code>i</code>.
  </li>
  <li>
    Set <code>curr = root</code>. Iterate <code>j</code> over the indices of
    <code>s</code>, starting from <code>i</code>. At each <code>j</code>,
    <ul>
      <li>
        Get the character at index <code>j</code> as <code>c = s[j]</code>.
      </li>
      <li>
        If <code>c</code> is not in the children of <code>curr</code>, we can
        <code>break</code> from the loop.
      </li>
      <li>
        Otherwise, move <code>curr</code> to the child labeled <code>c</code>.
      </li>
      <li>If <code>curr.isWord</code>, set <code>dp[j] = true</code>.</li>
    </ul>
  </li>
  <li>Return <code>dp[s.length - 1]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
struct TrieNode {
    bool isWord;
    unordered_map&lt;char, TrieNode*> children;
    TrieNode() : isWord(false), children(unordered_map&lt;char, TrieNode*>()) {}
};

class Solution {
public:
    bool wordBreak(string s, vector&lt;string>&amp; wordDict) {
        TrieNode* root = new TrieNode();
        for (string word : wordDict) {
            TrieNode* curr = root;
            for (char c : word) {
                if (curr->children.find(c) == curr->children.end()) {
                    curr->children[c] = new TrieNode();
                }
                curr = curr->children[c];
            }

            curr->isWord = true;
        }

        vector&lt;bool> dp(s.length());
        for (int i = 0; i &lt; s.length(); i++) {
            if (i == 0 || dp[i - 1]) {
                TrieNode* curr = root;
                for (int j = i; j &lt; s.length(); j++) {
                    char c = s[j];
                    if (curr->children.find(c) == curr->children.end()) {
                        // No words exist
                        break;
                    }

                    curr = curr->children[c];
                    if (curr->isWord) {
                        dp[j] = true;
                    }
                }
            }
        }

        return dp[s.length() - 1];
    }
};</pre
>

<p><strong>Complexity Analysis</strong></p>
<p>
  Given $n$ as the length of <code>s</code>, $m$ as the length of
  <code>wordDict</code>, and $k$ as the average length of the words in
  <code>wordDict</code>,
</p>
<ul>
  <li>Time complexity: $O(n^2 + m \cdot k)$</li>
</ul>
<p>
  Building the trie involves iterating over all characters of all words. This
  costs $O(m \cdot k)$.
</p>
<p>
  Once we build the trie, we calculate <code>dp</code>. For each <code>i</code>,
  we iterate over all the indices after <code>i</code>. We have a basic nested
  for loop which costs $O(n^2)$ to handle all <code>dp[i]</code>.
</p>
<ul>
  <li>Space complexity: $O(n + m \cdot k)$</li>
</ul>
<p>
  The <code>dp</code> array takes $O(n)$ space. The trie can have up to $m \cdot
  k$ nodes in it.
</p>
<p><br /></p>
<hr />
<h4>Approach 5: A Different DP</h4>
<p><strong>Intuition</strong></p>
<blockquote>
  <p>
    In this approach, we will take a look at another way to implement the DP
    algorithm. Note that this approach is the one covered in the video.
  </p>
</blockquote>
<p>
  Here, we let <code>dp[i]</code> hold the answer to the question: "is it
  possible to form <code>s</code> up to a length of <code>i</code>? To find the
  answer for each index, instead of iterating over the words in
  <code>wordDict</code> and checking if a <code>word</code> ends at the current
  index <code>i</code>, we will instead iterate over
  <strong>all substrings that end before index <code>i</code></strong
  >. If we find one of these substrings is in <code>wordDict</code>
  <strong>and</strong> we can form the string prior to the substring, then
  <code>dp[i] = true</code>.
</p>
<p>
  The reason we are checking for <strong>before</strong> index <code>i</code> is
  because we have slightly changed our <code>dp</code> definition here. In the
  previous problem, <code>i</code> represented the index of the last character.
  Here, <code>i</code> represents the length, so we are offset by one.
</p>
<p>
  Before starting the DP, we first convert <code>wordsDict</code> to a set so
  that we can perform the checks in $O(1)$. The rest of the algorithm follows
  similarly to the previous approaches.
</p>
<p><strong>Algorithm</strong></p>
<ol>
  <li>Convert <code>wordsDict</code> to a set <code>words</code>.</li>
  <li>
    Initialize an array <code>dp</code> of length <code>n + 1</code> with all
    values set to <code>false</code>.
  </li>
  <li>
    Iterate <code>i</code> from <code>1</code> until and including
    <code>n</code>. Here, <code>i</code> represents the length of the string
    starting from the beginning.
  </li>
  <li>
    Iterate <code>j</code> from <code>0</code> until <code>i</code>. Here,
    <code>j</code> represents the first index of the substring we are checking.
  </li>
  <li>
    If <code>dp[j]</code> is true AND the substring <code>s[j:i]</code> is in
    <code>words</code>, set <code>dp[i] = true</code> and break. Note that
    <code>s[j:i]</code> represents the substring starting at <code>j</code> and
    ending at <code>i - 1</code>.
  </li>
  <li>Return <code>dp[n]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
class Solution {
public:
    bool wordBreak(string s, vector&lt;string>&amp; wordDict) {
        unordered_set&lt;string> words(wordDict.begin(), wordDict.end());
        vector&lt;bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i &lt;= s.size(); i++) {
            for (int j = 0; j &lt; i; j++) {
                if (dp[j] &amp;&amp; words.count(s.substr(j, i - j))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.size()];
    }
};</pre
>

<p><strong>Complexity Analysis</strong></p>
<p>
  Given $n$ as the length of <code>s</code>, $m$ as the length of
  <code>wordDict</code>, and $k$ as the average length of the words in
  <code>wordDict</code>,
</p>
<ul>
  <li>Time complexity: $O(n^3 + m \cdot k)$</li>
</ul>
<p>
  First, we spend $O(m \cdot k)$ to convert <code>wordDict</code> into a set.
  Then we have a nested loop over <code>n</code>, which iterates $O(n^2)$ times.
  For each iteration, we have a substring operation which could cost up to
  $O(n)$. Thus this nested loop costs $O(n^3)$.
</p>
<ul>
  <li>Space complexity: $O(n + m \cdot k)$</li>
</ul>
<p>
  The <code>dp</code> array takes $O(n)$ space. The set <code>words</code> takes
  up $O(m \cdot k)$ space.
</p>
<p><br /></p>
<hr />
